import { CfnOutput, RemovalPolicy } from "aws-cdk-lib";
import {
  AttributeType,
  BillingMode,
  ITable,
  Table,
} from "aws-cdk-lib/aws-dynamodb";
import { PolicyStatement } from "aws-cdk-lib/aws-iam";
import { StartingPosition } from "aws-cdk-lib/aws-lambda";
import { DynamoEventSource } from "aws-cdk-lib/aws-lambda-event-sources";
import { NodejsFunction } from "aws-cdk-lib/aws-lambda-nodejs";
import { Bucket } from "aws-cdk-lib/aws-s3";
import {
  CfnStateMachine,
  Pass,
  StateMachine,
} from "aws-cdk-lib/aws-stepfunctions";
import { Construct } from "constructs";
import { readdirSync, writeFileSync } from "fs";
import { join } from "path";
import { normalizeMigrationName } from "../util";
import { asl } from "./asl";

export enum MigrationMode {
  ONCE_AND_CONTINUOUS = "ONCE_AND_CONTINUOUS",
  CONTINOUS = "CONTINUOUS",
  ONCE = "ONCE",
}

export interface DynamoDBMigrationsProps {
  /** List of DynamoDB tables that Migrations Constrct will be interacting with,
   * aka all source and target tables */
  tables: ITable[];
  /** Path to the folder with migrations relative to the root of the project */
  migrationsPath: string;

  /**
   * The mode of the migration. Defaults to CONTINUOUS_AND_BATCH.
   *
   * - CONTINUOUS: Migrations will be executed on only the data that comes to the table
   *   after the migration is deployed using DynamoDB Stream triggers.
   *
   * - ONCE: Migrations will be executed on the entire table data by scanning the whole table space
   *   and applying the migration function to each item. This process happens just once.
   *
   * - ONCE_AND_CONTINUOUS: Migrations will be executed both on existing data (once) and
   *   the data that comes to the table after the migration is deployed (continuous).
   */
  migrationMode?: MigrationMode;
}

export class DynamoDBMigrations extends Construct {
  constructor(scope: Construct, id: string, props: DynamoDBMigrationsProps) {
    super(scope, id);

    this.prepareMigrationsIndexFile(props.migrationsPath);

    const migrationsTable = new Table(this, "MigrationsTable", {
      partitionKey: {
        name: "id",
        type: AttributeType.STRING,
      },
      billingMode: BillingMode.PAY_PER_REQUEST,
    });

    const resultsBucket = new Bucket(this, "ResultsBucket", {
      removalPolicy: RemovalPolicy.DESTROY,
      autoDeleteObjects: true,
    });

    const stepFunctionsProcessor = new NodejsFunction(
      this,
      "StepFunctionsProcessor",
      {
        entry: "./lib/functions/processor.stepFunctions.ts",
      }
    );
    const dynamodbStreamProcessor = new NodejsFunction(
      this,
      "DynamoDBStreamProcessor",
      {
        entry: "./lib/functions/processor.dynamodbStream.ts",
      }
    );

    const stateMachine = new StateMachine(this, "MigrationStateMachine", {
      definition: new Pass(this, "Dummy"), // Will be replaced with the ASL definition via Escape Hatch
    });
    const cfnStatemachine = stateMachine.node.defaultChild as CfnStateMachine;

    resultsBucket.grantReadWrite(stateMachine);
    stepFunctionsProcessor.grantInvoke(stateMachine);

    stateMachine.addToRolePolicy(
      new PolicyStatement({
        actions: ["states:StartExecution"],
        resources: ["*"],
      })
    );

    cfnStatemachine.definitionString = JSON.stringify(
      asl(stepFunctionsProcessor.functionArn, resultsBucket.bucketName)
    );

    props.tables.forEach((table) => {
      table.grantFullAccess(stateMachine);
      table.grantReadWriteData(stepFunctionsProcessor);
      table.grantReadWriteData(dynamodbStreamProcessor);

      dynamodbStreamProcessor.addEventSource(
        new DynamoEventSource(table, {
          startingPosition: StartingPosition.LATEST,
        })
      );
    });

    new CfnOutput(this, "DynamoDBMigrationsMigrationsTableArn", {
      value: migrationsTable.tableArn,
    });
    new CfnOutput(this, "DynamoDBMigrationsMigrationMachineArn", {
      value: stateMachine.stateMachineArn,
    });
  }

  /**
   * Generates migrations.ts file which will be used by the processor function as an index file for all user defined migrations
   */
  private prepareMigrationsIndexFile(migrationsPath: string) {
    const migrations = readdirSync(migrationsPath);

    const normalizedMigrationsNames = migrations.map((migration) =>
      normalizeMigrationName(migration)
    );

    const lines = migrations.map(
      (migration, index) =>
        `export * as ${
          normalizedMigrationsNames[index]
        } from "../../${migrationsPath}/${migration.replace(".ts", "")}";`
    );

    const banner = `/* --- This file is autogenerated, do not edit it manually --- */`;

    const content = `${banner}
${lines.join("\n")}`;

    writeFileSync(
      join(__dirname, "..", "functions", "index.migrations.ts"),
      content,
      "utf8"
    );
  }
}
